"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIdentifierHoverResult = exports.getFunctionHoverResult = void 0;
const node_1 = require("vscode-languageserver/node");
const hints_1 = require("./hints");
const symbols_1 = require("./symbols");
const utils_1 = require("./utils");
function getFunctionHoverResult(context, nodeName, namespace, uri) {
    var _a;
    const { dependencies, symbols, namespaces, trees } = context;
    const allDeps = [...dependencies.getLinkedUris(uri)].filter((u) => { var _a; return namespace === 'awk' || ((_a = namespaces[u]) === null || _a === void 0 ? void 0 : _a.has(namespace)); });
    let funcDefinitionSymbol;
    for (const uri of allDeps) {
        const symbolInfos = (_a = symbols[uri]) === null || _a === void 0 ? void 0 : _a.get(nodeName);
        if (symbolInfos) {
            funcDefinitionSymbol = symbolInfos.find((si) => si.kind === node_1.SymbolKind.Function && si.containerName === namespace);
            if (funcDefinitionSymbol)
                break;
        }
    }
    if (!funcDefinitionSymbol)
        return null;
    const funcDefinitionNode = utils_1.getNodeAtRange(trees[funcDefinitionSymbol.location.uri], funcDefinitionSymbol.location.range);
    return {
        contents: {
            kind: 'markdown',
            value: hints_1.getFunctionHint(funcDefinitionNode),
        },
    };
}
exports.getFunctionHoverResult = getFunctionHoverResult;
function getSymbolInfoForName(nodeName, namespace, symbolsMap) {
    if (!symbolsMap.has(nodeName))
        return [];
    return symbolsMap
        .get(nodeName)
        .filter((si) => { var _a; return si.containerName === namespace || ((_a = si.containerName) === null || _a === void 0 ? void 0 : _a.startsWith(`${namespace}::`)); });
}
function getIdentifierHoverResult(context, nodeName, namespace, uri, position) {
    const { trees, symbols, namespaces, dependencies } = context;
    let nearestSymbol = null;
    let definitionNode;
    const symbolInfos = getSymbolInfoForName(nodeName, namespace, symbols[uri]);
    if (symbolInfos.length) {
        nearestSymbol = symbols_1.getNearestPrecedingSymbol(position, symbolInfos);
    }
    if (nearestSymbol) {
        definitionNode = utils_1.getNodeAtRange(trees[nearestSymbol.location.uri], nearestSymbol.location.range);
        // Prefer assignment over simple declaration
        if (!utils_1.isAssignment(definitionNode)) {
            nearestSymbol = null;
        }
    }
    if (!nearestSymbol) {
        const uriWithFinalDefinition = [...dependencies.getAllDepthFirst(uri)]
            .filter((u) => { var _a; return namespace === 'awk' || ((_a = namespaces[u]) === null || _a === void 0 ? void 0 : _a.has(namespace)); })
            .filter((u) => symbols[u])
            .reverse()
            .find((u) => getSymbolInfoForName(nodeName, namespace, symbols[u]).length);
        if (!uriWithFinalDefinition)
            return null;
        nearestSymbol = symbols_1.getFinalSymbolByPosition(getSymbolInfoForName(nodeName, namespace, symbols[uriWithFinalDefinition]));
    }
    if (!nearestSymbol)
        return null;
    definitionNode = utils_1.getNodeAtRange(trees[nearestSymbol.location.uri], nearestSymbol.location.range);
    return {
        contents: {
            kind: 'markdown',
            value: hints_1.getVariableHint(getDefinitionText(definitionNode), nearestSymbol.location.uri),
        },
    };
}
exports.getIdentifierHoverResult = getIdentifierHoverResult;
function getDefinitionText(node) {
    if (utils_1.isIdentifier(node) && node.parent) {
        if (utils_1.isParamList(node.parent)) {
            const funcDefNode = node.parent.parent;
            const firstLineOfText = funcDefNode.text.split('\n')[0];
            return firstLineOfText.includes(')')
                ? firstLineOfText.replace(/{/, '').trim()
                : `${funcDefNode.children[0].text} ${funcDefNode.children[1].text} (...${node.text})`;
        }
        if (utils_1.isBlock(node.parent)) {
            const offset = node.startPosition.row - node.parent.startPosition.row;
            return node.parent.text
                .split('\n')
                .filter((_, i) => offset - 1 <= i && i <= offset + 1)
                .join('\n');
        }
        return node.parent.text.split('\n')[0].trim();
    }
    return node.text.trim();
}
//# sourceMappingURL=hover.js.map