"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyMap = exports.DependencyNode = exports.difference = void 0;
function difference(set1, set2) {
    const result = new Set();
    set1.forEach((value) => {
        if (!set2.has(value))
            result.add(value);
    });
    return result;
}
exports.difference = difference;
class DependencyNode {
    constructor() {
        this.parentUris = new Set();
        this.childrenUris = new Set();
    }
}
exports.DependencyNode = DependencyNode;
class DependencyMap extends Map {
    get(uri) {
        if (!super.get(uri))
            super.set(uri, new DependencyNode());
        return super.get(uri);
    }
    update(uri, newDependencies) {
        const oldDependencies = this.get(uri).childrenUris;
        difference(oldDependencies, newDependencies).forEach((childUri) => {
            this.get(childUri).parentUris.delete(uri);
        });
        newDependencies.forEach((childUri) => {
            this.get(childUri).parentUris.add(uri);
        });
        this.get(uri).childrenUris = newDependencies;
    }
    hasParent(uri, parentUri, visitedUris = new Set()) {
        if (visitedUris.has(uri))
            return false;
        const { parentUris } = this.get(uri);
        if (parentUris.has(parentUri))
            return true;
        visitedUris.add(uri);
        for (const pu of parentUris) {
            if (this.hasParent(pu, parentUri, visitedUris))
                return true;
        }
        return false;
    }
    /**
     * Get entire dependency tree flattened to a set of URIs
     */
    getAllBreadthFirst(uri) {
        const result = new Set();
        const queue = [uri];
        result.add(uri);
        while (queue.length) {
            const uri = queue.shift();
            for (const u of this.get(uri).childrenUris) {
                if (result.has(u))
                    continue;
                result.add(u);
                queue.push(u);
            }
        }
        return result;
    }
    /**
     * Get entire dependency tree flattened to a set of URIs
     */
    getAllDepthFirst(uri) {
        const result = new Set();
        const stack = [uri];
        while (stack.length) {
            const uri = stack.pop();
            result.add(uri);
            for (const u of [...this.get(uri).childrenUris].reverse()) {
                if (result.has(u))
                    continue;
                stack.push(u);
            }
        }
        return result;
    }
    /**
     * Get document URIs which have access to the given document scope
     */
    getLinkedUris(queriedUri) {
        const result = new Set();
        const queue = [queriedUri];
        while (queue.length) {
            const uri = queue.shift();
            if (result.has(uri))
                continue;
            queue.push(...this.get(uri).childrenUris);
            queue.push(...this.get(uri).parentUris);
            result.add(uri);
        }
        return result;
    }
}
exports.DependencyMap = DependencyMap;
//# sourceMappingURL=dependencies.js.map