"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyze = void 0;
const node_1 = require("vscode-languageserver/node");
const hints_1 = require("./hints");
const utils_1 = require("./utils");
const kinds = {
    func_def: node_1.SymbolKind.Function,
    assignment_exp: node_1.SymbolKind.Variable,
    for_in_statement: node_1.SymbolKind.Variable,
    getline_input: node_1.SymbolKind.Variable,
    param_list: node_1.SymbolKind.Variable,
    identifier: node_1.SymbolKind.Variable,
};
function getSymbolInfoFromDefinition(node, uri) {
    const identifier = node.descendantsOfType('identifier')[0];
    const name = identifier.text;
    return node_1.SymbolInformation.create(name, kinds[node.type], utils_1.getRange(node), uri);
}
function getSymbolInfoFromParam(node, uri) {
    return node_1.SymbolInformation.create(utils_1.getName(node), kinds[node.type], utils_1.getRange(node), uri, utils_1.getParentFunctionName(node));
}
function getSymbolInfo(node, uri) {
    if (!node.parent)
        return null;
    if (utils_1.isParamList(node.parent)) {
        return getSymbolInfoFromParam(node, uri);
    }
    if (utils_1.getParentFunction(node))
        return null;
    if (utils_1.isDefinition(node.parent)) {
        return getSymbolInfoFromDefinition(node.parent, uri);
    }
    if (!['func_call'].includes(node.parent.type)) {
        return node_1.SymbolInformation.create(utils_1.getName(node), kinds[node.type], utils_1.getRange(node), uri);
    }
    return null;
}
function isKnownSymbol(symbols, symbolInfo) {
    for (const symbol of symbols) {
        if (symbol.name === symbolInfo.name &&
            symbol.containerName === symbolInfo.containerName)
            return true;
    }
    return false;
}
function getNamespaceMap(tree) {
    const result = new Map();
    const namespaces = tree.rootNode.namedChildren.filter(utils_1.isNamespace) || [];
    namespaces.forEach((ns, i) => {
        const nextNs = namespaces[i + 1];
        const name = ns.lastChild.text.slice(1, -1);
        const range = node_1.Range.create(utils_1.pointToPosition(ns.startPosition), utils_1.pointToPosition((nextNs === null || nextNs === void 0 ? void 0 : nextNs.startPosition) || tree.rootNode.endPosition));
        result.set(name, range);
    });
    return result;
}
function analyze(context, document, docs) {
    const tree = context.parser.parse(document.getText());
    const symbols = new Map();
    const namespaces = getNamespaceMap(tree);
    const dependencyUris = [];
    for (const node of utils_1.nodesGen(tree.rootNode)) {
        if (utils_1.isInclude(node) && node.childCount === 2) {
            const url = utils_1.getDependencyUrl(node, document.uri);
            dependencyUris.push(url.href);
        }
        if (utils_1.isNamespace(node)) {
            const name = utils_1.getNamespaceName(node);
            const symbolInfo = node_1.SymbolInformation.create(name, node_1.SymbolKind.Namespace, namespaces.get(name), document.uri);
            if (!symbols.get(symbolInfo.name))
                symbols.set(symbolInfo.name, []);
            symbols.get(symbolInfo.name).push(symbolInfo);
            continue;
        }
        if (!utils_1.isIdentifier(node))
            continue;
        const symbolInfo = getSymbolInfo(node, document.uri);
        if (!symbolInfo)
            continue;
        const ns = utils_1.getNamespace(node, namespaces);
        symbolInfo.containerName = symbolInfo.containerName
            ? `${ns}::${symbolInfo.containerName}`
            : ns;
        if (hints_1.getBuiltinHints(docs)[symbolInfo.name])
            continue;
        if (isKnownSymbol(symbols.get(symbolInfo.name) || [], symbolInfo))
            continue;
        if (!symbols.get(symbolInfo.name))
            symbols.set(symbolInfo.name, []);
        symbols.get(symbolInfo.name).push(symbolInfo);
    }
    return {
        tree,
        symbols,
        namespaces,
        document,
        dependencyUris,
    };
}
exports.analyze = analyze;
//# sourceMappingURL=analyze.js.map