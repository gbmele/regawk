"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNameCollision = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const utils_1 = require("../utils");
function isSameRange(range1, range2) {
    return (range1.start.line === range2.start.line &&
        range1.start.character === range2.start.character &&
        range1.end.line === range2.end.line &&
        range1.end.character === range2.end.character);
}
function validateNameCollision(context) {
    const { node, dependencies, symbols, namespaces, uri } = context;
    const namespace = utils_1.getNamespace(node, namespaces[uri]);
    if (node.type === 'func_def') {
        const name = utils_1.getFunctionName(node);
        const range = utils_1.getRange(node);
        const linkedUris = dependencies.getLinkedUris(uri);
        let existingDefinition;
        for (const sm of [...linkedUris].map((u) => symbols[u])) {
            const symbolInfos = sm === null || sm === void 0 ? void 0 : sm.get(name);
            if (!symbolInfos)
                continue;
            existingDefinition = symbolInfos.find((si) => si.containerName === namespace && si.kind === vscode_languageserver_1.SymbolKind.Function);
        }
        if (!existingDefinition)
            return null;
        const { uri: eduri, range: edrange } = existingDefinition.location;
        if (uri !== eduri || !isSameRange(range, edrange)) {
            return vscode_languageserver_1.Diagnostic.create(range, `Function name must be unique`, vscode_languageserver_1.DiagnosticSeverity.Error);
        }
    }
    return null;
}
exports.validateNameCollision = validateNameCollision;
//# sourceMappingURL=nameCollision.js.map