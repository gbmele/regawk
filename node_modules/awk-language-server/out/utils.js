"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNamespaceName = exports.isAssignment = exports.getNamespace = exports.isNodeWithinRange = exports.isPositionWithinRange = exports.isNamespace = exports.isBlock = exports.isAwkExtension = exports.isSwitch = exports.isLoop = exports.getParentFunctionName = exports.getParentFunction = exports.getPrecedingComments = exports.getFunctionSignature = exports.pointToPosition = exports.positionToPoint = exports.getDependencyUrl = exports.getQueriesList = exports.findReferences = exports.isIdentifier = exports.isFunction = exports.isInclude = exports.isReference = exports.isParamList = exports.isDefinition = exports.getFunctionName = exports.getName = exports.getNodeAtRange = exports.getNodeAt = exports.getRange = exports.findParent = exports.nodesGen = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const url_1 = require("url");
const node_1 = require("vscode-languageserver/node");
function* nodesGen(node) {
    const queue = [node];
    while (queue.length) {
        const n = queue.shift();
        if (!n)
            return;
        if (n.children.length) {
            queue.unshift(...n.children);
        }
        yield n;
    }
}
exports.nodesGen = nodesGen;
function findParent(start, predicate) {
    let node = start.parent;
    while (node !== null) {
        if (predicate(node))
            return node;
        node = node.parent;
    }
    return null;
}
exports.findParent = findParent;
function getRange(node) {
    return node_1.Range.create(node.startPosition.row, node.startPosition.column, node.endPosition.row, node.endPosition.column);
}
exports.getRange = getRange;
function getNodeAt(tree, line, column) {
    if (!tree.rootNode)
        return null;
    return tree.rootNode.descendantForPosition({ row: line, column });
}
exports.getNodeAt = getNodeAt;
function getNodeAtRange(tree, range) {
    if (!tree.rootNode)
        return null;
    return tree.rootNode.descendantForPosition(positionToPoint(range.start), positionToPoint(range.end));
}
exports.getNodeAtRange = getNodeAtRange;
/** Get textual representation of the node (variable name, field & array reference, but not function name) */
function getName(node) {
    if (!node)
        return null;
    if (node.childCount) {
        if (!['field_ref', 'array_ref'].includes(node.type))
            return null;
    }
    return node.text.trim() || null;
}
exports.getName = getName;
function getFunctionName(node) {
    return node.descendantsOfType('identifier')[0].text.trim();
}
exports.getFunctionName = getFunctionName;
function isDefinition(node) {
    if (['assignment_exp', 'func_def', 'for_in_statement'].includes(node.type))
        return true;
    if (node.type === 'getline_input' && node.firstNamedChild)
        return true;
    return false;
}
exports.isDefinition = isDefinition;
function isParamList(node) {
    return node.type === 'param_list';
}
exports.isParamList = isParamList;
function isReference(node) {
    return ['array_ref', 'field_ref', 'identifier'].includes(node.type);
}
exports.isReference = isReference;
function isInclude(node) {
    var _a;
    return node.type === 'directive' && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.text) === '@include';
}
exports.isInclude = isInclude;
function isFunction(node) {
    return node.type === 'func_def' || node.type === 'func_call';
}
exports.isFunction = isFunction;
function isIdentifier(node) {
    return node.type === 'identifier';
}
exports.isIdentifier = isIdentifier;
function findReferences(startingNode, startingNamespaces, searchedNode, searchedNamespaces) {
    const result = [];
    const name = getName(searchedNode);
    const ns = getNamespace(searchedNode, searchedNamespaces);
    for (const node of nodesGen(startingNode)) {
        if (!isReference(node) && !isDefinition(node))
            continue;
        if (getName(node) === name && getNamespace(node, startingNamespaces) === ns)
            result.push(getRange(node));
    }
    return result;
}
exports.findReferences = findReferences;
function getQueriesList(queriesRawText) {
    const result = [];
    let openParenCount = 0;
    let openBracketCount = 0;
    let isQuoteCharMet = false;
    let isComment = false;
    let currentQuery = '';
    for (const char of queriesRawText) {
        if (char === '"')
            isQuoteCharMet = !isQuoteCharMet;
        if (isQuoteCharMet) {
            currentQuery += char;
            continue;
        }
        else if (!isQuoteCharMet && char === ';')
            isComment = true;
        else if (isComment && char !== '\n')
            continue;
        else if (char === '(')
            openParenCount++;
        else if (char === ')')
            openParenCount--;
        else if (char === '[')
            openBracketCount++;
        else if (char === ']')
            openBracketCount--;
        else if (char === '\n') {
            isComment = false;
            if (!openParenCount && !openBracketCount && currentQuery) {
                result.push(currentQuery.trim());
                currentQuery = '';
            }
            continue;
        }
        if (!isComment)
            currentQuery += char;
    }
    return result;
}
exports.getQueriesList = getQueriesList;
function getDependencyUrl(node, baseUri) {
    var _a;
    let filename = node.children[1].text.replaceAll('"', '');
    if (!filename.endsWith('.awk') && !filename.endsWith('.gawk')) {
        // The way GAWK behaves
        filename += '.awk';
    }
    const paths = ((_a = process.env.AWKPATH) === null || _a === void 0 ? void 0 : _a.split(':')) || [];
    for (const p of paths) {
        const url = url_1.pathToFileURL(path_1.join(p, filename));
        if (fs_1.existsSync(url))
            return url;
    }
    return new url_1.URL(filename, baseUri);
}
exports.getDependencyUrl = getDependencyUrl;
function positionToPoint(pos) {
    return {
        row: pos.line,
        column: pos.character,
    };
}
exports.positionToPoint = positionToPoint;
function pointToPosition(point) {
    return {
        line: point.row,
        character: point.column,
    };
}
exports.pointToPosition = pointToPosition;
function getFunctionSignature(node) {
    var _a, _b, _c;
    if (!isFunction(node)) {
        throw new Error(`Node type ${node.type} is not a function`);
    }
    const params = (_c = (_b = (_a = node
        .descendantsOfType('param_list')[0]) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b.replaceAll(/#.*/g, '')) === null || _c === void 0 ? void 0 : _c.replaceAll(/\s+/g, ' ');
    return `${node.firstNamedChild.text}(${params || ''})`;
}
exports.getFunctionSignature = getFunctionSignature;
function getPrecedingComments(node) {
    if (!node)
        return '';
    let comment = [];
    let currentNode = node.previousNamedSibling;
    while ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type) === 'comment') {
        comment.unshift(currentNode.text.replaceAll(/#+\s?/g, ''));
        currentNode = currentNode.previousNamedSibling;
    }
    return comment.join('\n');
}
exports.getPrecedingComments = getPrecedingComments;
/** Get function node if given node is defined among its parameters */
function getParentFunction(node) {
    const parentFunc = findParent(node, (p) => p.type === 'func_def');
    if (!parentFunc)
        return null;
    const paramList = parentFunc.namedChildren[1].type === 'param_list' ? parentFunc.namedChildren[1] : null;
    if (!paramList)
        return null;
    const name = getName(node);
    if (!name)
        return null;
    for (const param of paramList.children) {
        if (name === getName(param))
            return parentFunc;
    }
    return null;
}
exports.getParentFunction = getParentFunction;
/** Get function name if node is defined among its parameters */
function getParentFunctionName(node) {
    const parentFunc = getParentFunction(node);
    return parentFunc ? getName(parentFunc.firstNamedChild) : null;
}
exports.getParentFunctionName = getParentFunctionName;
function isLoop(node) {
    return [
        'for_statement',
        'for_in_statement',
        'while_statement',
        'do_while_statement',
    ].includes(node.type);
}
exports.isLoop = isLoop;
function isSwitch(node) {
    return node.type === 'switch_statement';
}
exports.isSwitch = isSwitch;
function isAwkExtension(path) {
    const ext = path_1.extname(path).toLowerCase();
    return ext === '.awk' || ext === '.gawk';
}
exports.isAwkExtension = isAwkExtension;
function isBlock(node) {
    return node.type === 'block';
}
exports.isBlock = isBlock;
function isNamespace(node) {
    return node.type === 'directive' && node.firstChild.text === '@namespace';
}
exports.isNamespace = isNamespace;
function isPositionWithinRange(position, range) {
    const doesStartInside = position.line > range.start.line ||
        (position.line === range.start.line && position.character >= range.start.character);
    const doesEndInside = position.line < range.end.line ||
        (position.line === range.end.line && position.character <= range.end.character);
    return doesStartInside && doesEndInside;
}
exports.isPositionWithinRange = isPositionWithinRange;
function isNodeWithinRange(node, range) {
    const doesStartInside = node.startPosition.row > range.start.line ||
        (node.startPosition.row === range.start.line &&
            node.startPosition.column >= range.start.character);
    const doesEndInside = node.endPosition.row < range.end.line ||
        (node.endPosition.row === range.end.line &&
            node.endPosition.column <= range.end.character);
    return doesStartInside && doesEndInside;
}
exports.isNodeWithinRange = isNodeWithinRange;
/** Get namespace which node belongs to */
function getNamespace(node, namespaces) {
    var _a;
    if (isIdentifier(node) && ((_a = node.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === 'namespace')
        return node.previousNamedSibling.text;
    for (const [ns, range] of namespaces) {
        if (isNodeWithinRange(node, range))
            return ns;
    }
    return 'awk';
}
exports.getNamespace = getNamespace;
function isAssignment(node) {
    return [
        'assignment_exp',
        'update_exp',
        'for_in_statement',
        'getline_input',
        'getline_file',
    ].includes(node.type);
}
exports.isAssignment = isAssignment;
/** Get namespace name on directive node */
function getNamespaceName(node) {
    return node.lastChild.text.slice(1, -1);
}
exports.getNamespaceName = getNamespaceName;
//# sourceMappingURL=utils.js.map