"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHoverHandler = void 0;
const hints_1 = require("../hints");
const hover_1 = require("../hover");
const utils_1 = require("../utils");
function isFunction(node) {
    var _a;
    const parent = ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'ns_qualified_name' ? node.parent.parent : node.parent;
    if (!parent)
        return false;
    return ['func_call', 'func_def'].includes(parent.type);
}
function getHoverHandler(context) {
    const { trees, namespaces, docs } = context;
    return function handleHover(params) {
        var _a;
        const { uri } = params.textDocument;
        const { line, character } = params.position;
        let node = utils_1.getNodeAt(trees[uri], line, character);
        if (!node)
            return null;
        if (node.type === 'string' && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'array_ref') {
            node = node.parent;
        }
        const name = utils_1.getName(node);
        if (!name)
            return null;
        const builtins = hints_1.getBuiltinHints(docs);
        if (builtins[name]) {
            return { contents: { kind: 'markdown', value: builtins[name] } };
        }
        const ns = utils_1.getNamespace(node, namespaces[uri] || new Map());
        if (isFunction(node)) {
            return hover_1.getFunctionHoverResult(context, name, ns, uri);
        }
        if (node.type === 'identifier') {
            return hover_1.getIdentifierHoverResult(context, name, ns, uri, params.position);
        }
        return null;
    };
}
exports.getHoverHandler = getHoverHandler;
//# sourceMappingURL=handleHover.js.map